package nez.x;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import nez.Grammar;
import nez.ast.AST;
import nez.expr.Expression;
import nez.expr.Rule;

public class DTDConverter extends GrammarConverter {
	int attID;
	int attDefCount = 0;
	int elementCount = 0;
	int entityCount = 0;
	Map<Integer, String> elementMap = new HashMap<>();
	Map<String, Integer> attributeMap = new HashMap<>();
	List<Integer> reqList;
	List<Integer> impList;
	

	public DTDConverter(Grammar grammar, String name) {
		super(grammar, name);
	}

	@Override
	public void convert(AST node) {
		this.visit("visit", node);
		System.out.println("\nConverted Rule: " + grammar.getResourceName());
		grammar.dump();
		file.write("// This file is generated by src.nez.x.DTDConverter.java");
		file.writeIndent("// Generate Date: " + new Date().toString());
		file.writeIndent("// Input DTD :  " + node.getText());
		file.writeIndent("\n");
		for(Rule r : grammar.getRuleList()) {
			file.write(r.toString());
			file.writeIndent("\n");
		}
		file.flush();
	}
	
	public void initAttCounter() {
		attID = elementCount - 1;
		attDefCount = 0;
		reqList = new ArrayList<Integer>();
		impList = new ArrayList<Integer>();
	}

	public int[] initAttDefList() {
		int[] attDefList = new int[attDefCount];
		for (int i = 0; i < attDefList.length; i++) {
			attDefList[i] = i;
		}
		return attDefList;
	}

	public void visitDoc(AST node) {
		for(AST subnode: node) {
			this.visit("visit", subnode);
		}
		for (int elementID = 0; elementID < elementCount; elementID++) {
			String elementName = "Element_" + elementMap.get(elementID);
			grammar.defineRule(node, elementName, genElement(node, elementID));
		}
		grammar.defineRule(node, "entity", genEntityList(node));
	}



	public void visitElement(AST node) {
		String elementName = node.textAt(0, "");
		elementMap.put(elementCount, elementName);
		grammar.defineRule(node, "Content" + elementCount, toExpression(node.get(1)));
		elementCount++;
	}

	private Expression genElement(AST node, int elementID) {
		String elementName = elementMap.get(elementID);
		// check whether attribute exists
		if (attributeMap.containsValue(elementID)) {
			Expression[] l = {
			grammar.newString("<" + elementName),
					grammar.newNonTerminal("Attribute" + elementID),
			grammar.newString(">"),
					grammar.newNonTerminal("Content" + elementID),
			grammar.newString("</" + elementName + ">")
			};
			return grammar.newSequence(l);
		}
		else {
			Expression[] l = {
			grammar.newString("<" + elementName),
			grammar.newString( ">"),
					grammar.newNonTerminal("Content" + elementID),
			grammar.newString("</" + elementName + ">")
			};
			return grammar.newSequence(l);
		}
	}

	public void visitAttlist(AST node) {
		initAttCounter();
		String elementName = node.textAt(0, "");
		attributeMap.put(elementName, attID);
		String attListName = "Attribute" + attID;
		String choiceListName = "AttChoice" + attID;
		for (int attNum = 1; attNum < node.size(); attNum++) {
			this.visit("visit", node.get(attNum));
		}
		int[] attDefList = initAttDefList();
		// generate Complete / Proximate Attribute list
		if (impList.isEmpty()) {
			grammar.defineRule(node, attListName, genCompAtt(node, attDefList));
		} else {
			int[] requiredRules = extractRequiredRule(attDefList);
			grammar.defineRule(node, choiceListName, genImpliedChoice(node));
			grammar.defineRule(node, attListName, genProxAtt(node, requiredRules));
		}
	}

	public void visitREQUIRED(AST node) {
		String name = "AttDef" + attID + "_" + attDefCount;
		reqList.add(attDefCount++);
		grammar.defineRule(node, name, toExpression(node.get(1)));
	}

	public void visitIMPLIED(AST node) {
		String name = "AttDef" + attID + "_" + attDefCount;
		impList.add(attDefCount++);
		grammar.defineRule(node, name, toExpression(node.get(1)));
	}

	public void visitFIXED(AST node) {
		String name = "AttDef" + attID + "_" + attDefCount;
		impList.add(attDefCount++);
		grammar.defineRule(node, name, genFixedAtt(node));
	}


	public void visitDefault(AST node) {
		String name = "AttDef" + attID + "_" + attDefCount;
		impList.add(attDefCount++);
		grammar.defineRule(node, name, toExpression(node.get(1)));
	}

	public void visitEntity(AST node) {
		String name = "ENT_" + entityCount++;
		grammar.defineRule(node, name, toExpression(node.get(1)));
	}
	
	private Expression toExpression(AST node) {
		return (Expression)this.visit("to", node);
	}
	
	public Expression toEmpty(AST node) {
		return grammar.newNonTerminal("EMPTY");
	}

	public Expression toAny(AST node) {
		return grammar.newNonTerminal("ANY");
	}

	public Expression toZeroMore(AST node) {
		return grammar.newRepetition(toExpression(node.get(0)));
	}

	public Expression toOneMore(AST node) {
		Expression[] l = {
		toExpression(node.get(0)),
		grammar.newRepetition(toExpression(node.get(0)))
		};
		return grammar.newSequence(l);
	}

	public Expression toOption(AST node) {
		return grammar.newOption(toExpression(node.get(0)));
	}

	public Expression toChoice(AST node) {
		Expression[] l = new Expression[node.size()];
		int count = 0;
		for (AST subnode : node) {
			l[count++] = toExpression(subnode);
		}
		return grammar.newChoice(l);
	}

	public Expression toSeq(AST node) {
		Expression[] l = new Expression[node.size()];
		int count = 0;
		for (AST subnode : node) {
			l[count++] = toExpression(subnode);
		}
		return grammar.newSequence(l);
	}

	public Expression toCDATA(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newNonTerminal("STRING"),
		};
		return grammar.newSequence(l);
	}

	public Expression toID(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newString("\""),
				grammar.newNonTerminal("IDTOKEN"),
				grammar.newString("\"")
		//		grammar.newDefSymbol(Tag.tag("IDLIST"),
		//				grammar.newNonTerminal("IDTOKEN")));
		};
		return grammar.newSequence(l);

	}

	public Expression toIDREF(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newString("\""),
				grammar.newNonTerminal("IDTOKEN"),
				grammar.newString("\"")
		};
		return grammar.newSequence(l);
	}

	public Expression toIDREFS(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newString("\""),
				grammar.newNonTerminal("IDTOKENS"),
				grammar.newString("\"")
		//(grammar.newRepetition(node, grammar.newIsaSymbol(node, Tag.tag("IDLIST"))));
		};
		return grammar.newSequence(l);
	}

	private Expression genFixedAtt(AST node) {
		String attName = node.textAt(0, "");
		String fixedValue = node.textAt(2, "");
		Expression[] l ={
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newString(fixedValue),
		};
		return grammar.newSequence(l);
	}

	public Expression toENTITY(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l ={
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newString("\""),
				grammar.newNonTerminal("entity"),
				grammar.newString("\"")
		};
		return grammar.newSequence(l);
	}

	public Expression toENTITIES(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newString("\""),
				grammar.newNonTerminal("entities"),
				grammar.newString("\"")
		};
		return grammar.newSequence(l);
	}

	public Expression toNMTOKEN(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newNonTerminal("NMTOKEN"),
		};
		return grammar.newSequence(l);
	}

	public Expression toNMTOKENS(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName),
				grammar.newNonTerminal("S"),
				grammar.newByteChar('='),
				grammar.newNonTerminal("S"),
				grammar.newNonTerminal("NMTOKEN"),
		};
		return grammar.newSequence(l);
	}
	
	public Expression genCompAtt(AST node, int[] attlist) {
		int listLength = attlist.length;
		if (listLength == 1) {
			Expression[] l = {
					grammar.newNonTerminal("AttDef" + attID + "_" + attlist[0]),
					grammar.newRepetition(grammar.newNonTerminal("_")),
					grammar.newNonTerminal("ENDTAG")
			};
			return grammar.newSequence(l);
		} else {
			int[][] permutationList = perm(attlist);
			Expression[] choiceList = new Expression[permutationList.length];
			int choiceCount = 0;
			for (int[] target : permutationList) {
				Expression[] seqList = new Expression[listLength + 1];
				for (int index = 0; index < target.length; index++) {
					seqList[index] = grammar.newNonTerminal("AttDef" + attID + "_"
							+ target[index]);
				}
				seqList[listLength] = grammar.newNonTerminal("ENDTAG");
				choiceList[choiceCount++] = grammar.newSequence(seqList);
			}
			return grammar.newChoice(choiceList);
		}
	}

	public Expression genProxAtt(AST node, int[] attlist) {
		int listLength = attlist.length;
		if (listLength == 0) {
			Expression[] l = {
					grammar.newRepetition(grammar.newNonTerminal("AttChoice" + attID)),
					grammar.newNonTerminal("S"),
					grammar.newNonTerminal("ENDTAG")
			};
			return grammar.newSequence(l);
		} else {
			int[][] permedList = perm(attlist);
			Expression[] choiceList = new Expression[permedList.length];
			int choiceCount = 0;
			for (int[] target : permedList) {
				Expression[] seqList = new Expression[listLength * 2 + 2];
				int seqCount = 0;
				seqList[seqCount++] = grammar
						.newRepetition(grammar.newNonTerminal("AttChoice" + attID));
				for (int index = 0; index < target.length; index++) {
					seqList[seqCount++] = grammar.newNonTerminal("AttDef" + attID + "_"
							+ target[index]);
					seqList[seqCount++] = grammar.newRepetition(grammar.newNonTerminal("AttChoice"
							+ attID));
				}
				seqList[seqCount] = grammar.newNonTerminal("ENDTAG");
				choiceList[choiceCount++] = grammar.newSequence(seqList);
			}
			return grammar.newChoice(choiceList);
		}
	}

	public Expression genImpliedChoice(AST node){
		Expression[] l = new Expression[impList.size()];
		String definitionName = "AttDef" + attID + "_";
		int choiceCount = 0;
		for (Integer ruleNum : impList) {
			l[choiceCount++] = grammar.newNonTerminal(definitionName + ruleNum);
		}
		return grammar.newChoice(l);
	}
	

	public Expression toEnum(AST node) {
		String attName = node.getParent().textAt(0, "");
		Expression[] l = {
				grammar.newString(attName + "="),
				toChoice(node)
		};
		return grammar.newSequence(l);
	}

	public Expression toEntValue(AST node) {
		String replaceString = node.getText();
		return grammar.newString(replaceString);
	}

	public Expression toElName(AST node) {
		String elementName = "Element_" + node.getText();
		return grammar.newNonTerminal(elementName);
	}
	public Expression toData(AST node) {
		return grammar.newNonTerminal("PCDATA");
	}

	private Expression genEntityList(AST node) {
		if (entityCount == 0) {
			return grammar.newNonTerminal("NotAny");
		}
		else {
			Expression[] l = new Expression[entityCount];
			for (int entityNum = 0; entityNum < entityCount; entityNum++) {
				l[entityNum] = grammar.newNonTerminal("ENT_" + entityNum);
			}
			return grammar.newChoice(l);
		}
	}

	private final int[] extractRequiredRule(int[] attlist) {
		int[] buf = new int[512];
		int arrIndex = 0;
		for (int requiredNum : attlist) {
			if (reqList.contains(requiredNum)) {
				buf[arrIndex++] = requiredNum;
			}
		}
		int[] target = new int[arrIndex];
		for (int i = 0; i < arrIndex; i++) {
			target[i] = buf[i];
		}
		return target;
	}

	private int[][] perm(int[] attlist) {
		Permutation permutation = new Permutation(attlist);
		return permutation.getPermList();
	}

	@Override
	public String getDesc() {
		return "dtd";
	}

}


