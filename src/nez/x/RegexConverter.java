package nez.x;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Date;
import java.util.HashMap;

import nez.Grammar;
import nez.ast.AST;
import nez.ast.Node;
import nez.ast.NodeVisitor;
import nez.ast.Tag;
import nez.expr.Expression;
import nez.expr.Factory;
import nez.expr.Rule;
import nez.util.ConsoleUtils;
import nez.util.FileBuilder;
import nez.util.StringUtils;
import nez.util.UList;

public class RegexConverter extends NodeVisitor{
	final protected FileBuilder file;
	HashMap<Integer, Method> methodMap = new HashMap<Integer, Method>();
	int NonTerminalCount = 0;
	Grammar grammar;
	public RegexConverter(Grammar grammar) {
		this.grammar = grammar;
		this.file = new FileBuilder(grammar.getResourceName());
	}
	
	public final Expression pi(Node expr, Expression k) {
		Tag tag = expr.getTag();
		Method m = lookupPiMethod("pi", tag.id);
		if(m != null) {
			try {
				return (Expression)m.invoke(this, expr, k);
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				System.err.println(expr);
				e.printStackTrace();
			}
		}
		return null;
	}
	
	protected Method lookupPiMethod(String method, int tagId) {
		Integer key = tagId;
		Method m = this.methodMap.get(key);
		if(m == null) {
			String name = method + Tag.tag(tagId).getName();
			try {
				m = this.getClass().getMethod(name, AST.class, Expression.class);
			} catch (NoSuchMethodException e) {
				e.printStackTrace();
				return null;
			} catch (SecurityException e) {
				return null;
			}
			this.methodMap.put(key, m);
		}
		return m;
	}
	
	public void convert(AST e) {
		grammar.defineRule(e, "Pattern", pi(e, null));
		System.out.println("\nConverted Rule: " + grammar.getResourceName());
		grammar.dump();
		file.write("// This file is generated by src.nez.x.RegexConverter.java");
		file.writeIndent("// Generate Date: " + new Date().toString());
		file.writeIndent("// Input regex :  " + e.getText());
		file.writeIndent("\n");
		for(Rule r : grammar.getRuleList()) {
			file.write(r.toString());
			file.writeIndent("\n");
		}
		file.flush();
	}
	
	public Expression piPattern(AST e, Expression k) {
		return this.pi(e.get(0), k);
	}

	public Expression piOr(AST e, Expression k) {
		return toChoice(e, pi(e.get(0), k), pi(e.get(1), k));
	}

	public Expression piConcatenation(AST e, Expression k) {
		return pi(e.get(0), pi(e.get(1), k));
	}

	public Expression piIndependentExpr(AST e, Expression k) {
		return toSeq(e, pi(e.get(0), toEmpty(e)), k);
	}

	public Expression piAnd(AST e, Expression k) {
		return toAnd(e, k);
	}

	public Expression piNot(AST e, Expression k) {
		return toNot(e, k);
	}

	public Expression piPossessiveRepetition(AST e, Expression k) {
		return toSeq(e, piRepetition(e, toEmpty(e)), k);
	}

	public Expression piLazyQuantifiers(AST e, Expression k) {
		String ruleName = "Repetition" + NonTerminalCount++;
		Expression ne = Factory.newNonTerminal(e, this.grammar, ruleName);
		grammar.defineRule(e, ruleName, toChoice(e, k, pi(e.get(0), ne)));
		return ne;
	}

	public Expression piRepetition(AST e, Expression k) {
		String ruleName = "Repetition" + NonTerminalCount++;
		Expression ne = Factory.newNonTerminal(e, this.grammar, ruleName);
		grammar.defineRule(e, ruleName, toChoice(e, pi(e.get(0), ne), k));
		return ne;
	}

	public Expression piOneMoreRepetition(AST e, Expression k) {
		return pi(e.get(0), piRepetition(e, k));
	}

	public Expression piAny(AST e, Expression k) {
		return toAny(e);
	}

	public Expression piNegativeCharacterSet(AST e, Expression k) {
		Expression nce = toSeq(e, Factory.newNot(e, toCharacterSet(e)), toAny(e));
		return toSeq(e, nce, k);
	}

	public Expression piCharacterSet(AST e, Expression k) {
		return toSeq(e, k);
	}

	public Expression piCharacterRange(AST e, Expression k) {
		return toSeq(e, k);
	}
	
	public Expression piCharacterSetItem(AST e, Expression k) {
		return toSeq(e, k);
	}

	public Expression piCharacter(AST e, Expression k) {
		return toSeq(e, k);
	}
	
	private Expression toExpression(AST node) {
		return (Expression)this.visit("to", node);
	}
	
	public Expression toCharacter(AST node) {
		String text = node.getText();
		byte[] utf8 = StringUtils.toUtf8(text);
		if (utf8.length !=1) {
			ConsoleUtils.exit(1, "Error: not Character Literal");
		}
		return Factory.newByteChar(node, utf8[0]);
	}
	
	boolean byteMap[];
	boolean useByteMap = true;
	public Expression toCharacterSet(AST node) {
		UList<Expression> l = new UList<Expression>(new Expression[node.size()]);
		byteMap = new boolean[257];
		for(AST subnode: node) {
			Factory.addChoice(l, toExpression(subnode));
		}
		if (useByteMap) {
			return Factory.newByteMap(node, byteMap);
		}
		else {
			return Factory.newChoice(node, l);
		}
	}
	
	public Expression toCharacterRange(AST node) {
		byte[] begin = StringUtils.toUtf8(node.get(0).getText());
		byte[] end = StringUtils.toUtf8(node.get(1).getText());
		for(byte i = begin[0]; i <= end[0]; i++) {
			byteMap[i] = true;
		}
		return Factory.newCharSet(node, node.get(0).getText(), node.get(1).getText());
	}
	
	public Expression toCharacterSetItem(AST node) {
		byte[] utf8 = StringUtils.toUtf8(node.getText());
		byteMap[utf8[0]] = true;
		return Factory.newByteChar(node, utf8[0]);
	}
	
	public Expression toEmpty(AST node) {
		return Factory.newEmpty(node);
	}

	public Expression toAny(AST node) {
		return Factory.newAnyChar(node);
	}
	
	public Expression toAnd(AST node, Expression k) {
		return toSeq(node, Factory.newAnd(node, pi(node.get(0), toEmpty(node))), k);
	}
	
	public Expression toNot(AST node, Expression k) {
		return toSeq(node, Factory.newNot(node, pi(node.get(0), toEmpty(node))), k);
	}

	public Expression toChoice(AST node, Expression left, Expression right) {
		UList<Expression> l = new UList<Expression>(new Expression[2]);
		Factory.addChoice(l, left);
		if (right != null) {
			Factory.addChoice(l, right);
		}
		else {
			Factory.addChoice(l, toEmpty(node));
		}
		return Factory.newChoice(node, l);
	}

	public Expression toSeq(AST node, Expression k) {
		UList<Expression> l = new UList<Expression>(new Expression[2]);
		Factory.addSequence(l, toExpression(node));
		if(k != null) {
			Factory.addSequence(l, k);
		}
		return Factory.newSequence(node, l);
	}
	
	public Expression toSeq(AST node, Expression left, Expression right) {
		UList<Expression> l = new UList<Expression>(new Expression[2]);
		Factory.addSequence(l, left);
		if (right != null) {
			Factory.addSequence(l, right);
		}
		return Factory.newSequence(node, l);
	}
}
